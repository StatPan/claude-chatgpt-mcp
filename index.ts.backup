#!/usr/bin/env node
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
	CallToolRequestSchema,
	ListToolsRequestSchema,
	type Tool,
} from "@modelcontextprotocol/sdk/types.js";
import { runAppleScript } from "run-applescript";
import { run } from "@jxa/run";

// Define the ChatGPT tool
const CHATGPT_TOOL: Tool = {
	name: "chatgpt",
	description: "Interact with the ChatGPT desktop app on macOS",
	inputSchema: {
		type: "object",
		properties: {
			operation: {
				type: "string",
				description: "Operation to perform: 'ask', 'get_conversations', or 'get_last_message'",
				enum: ["ask", "get_conversations", "get_last_message"],
			},
			prompt: {
				type: "string",
				description:
					"The prompt to send to ChatGPT (required for ask operation)",
			},
			conversation_id: {
				type: "string",
				description:
					"Optional conversation ID to continue a specific conversation",
			},
		},
		required: ["operation"],
	},
};

const server = new Server(
	{
		name: "ChatGPT MCP Tool",
		version: "1.0.0",
	},
	{
		capabilities: {
			tools: {},
		},
	},
);

// Check if ChatGPT app is installed and running
async function checkChatGPTAccess(): Promise<boolean> {
	try {
		const isRunning = await runAppleScript(`
      tell application "System Events"
        return application process "ChatGPT" exists
      end tell
    `);

		if (isRunning !== "true") {
			console.log("ChatGPT app is not running, attempting to launch...");
			try {
				await runAppleScript(`
          tell application "ChatGPT" to activate
          delay 2
        `);
			} catch (activateError) {
				console.error("Error activating ChatGPT app:", activateError);
				throw new Error(
					"Could not activate ChatGPT app. Please start it manually.",
				);
			}
		}

		return true;
	} catch (error) {
		console.error("ChatGPT access check failed:", error);
		throw new Error(
			`Cannot access ChatGPT app. Please make sure ChatGPT is installed and properly configured. Error: ${error instanceof Error ? error.message : String(error)}`,
		);
	}
}

// Function to send a prompt to ChatGPT
async function askChatGPT(
	prompt: string,
	conversationId?: string,
): Promise<string> {
	await checkChatGPTAccess();
	try {
		// Function to check if text contains Korean characters
		const hasKorean = (text: string): boolean => {
			return /[가-힣ㄱ-ㅎㅏ-ㅣ]/.test(text);
		};

		// Function to properly encode text for AppleScript, including handling of Chinese characters
		const encodeForAppleScript = (text: string): string => {
			// Only escape double quotes, leave other characters as is
			return text.replace(/"/g, '\\"');
		};

		const encodedPrompt = encodeForAppleScript(prompt);
		const useClipboard = hasKorean(prompt);
		
		const script = `
      tell application "ChatGPT"
        activate
        delay 2
      end tell
      
      tell application "System Events"
        tell process "ChatGPT"
          -- Check if ChatGPT window exists
          if not (exists window 1) then
            return "ChatGPT window not found"
          end if
          
          ${
						conversationId
							? `
            try
              click button "${conversationId}" of group 1 of group 1 of window 1
              delay 1
            end try
          `
							: ""
					}
          
          -- ChatGPT accepts direct keyboard input, no need to click specific elements
          -- Clear any existing text using key codes
          key code 0 using {command down}  -- cmd+a
          delay 0.5
          key code 51  -- delete key
          delay 1.5
          
          ${useClipboard ? `
          -- Use clipboard + key codes for Korean text
          set the clipboard to "${encodedPrompt}"
          delay 0.5
          key code 9 using {command down}  -- cmd+v
          delay 2
          ` : `
          -- For English text, type directly
          keystroke "${encodedPrompt}"
          delay 2
          `}
          
          -- Send the message using key code
          key code 36  -- return key
          delay 1
          
          -- Wait for ChatGPT to respond
          delay 5
          
          -- Get the conversation text
          set conversationText to {}
          try
            set allUIElements to entire contents of window 1
            repeat with i from 1 to count of allUIElements
              try
                set currentElement to item i of allUIElements
                if (role of currentElement) is "AXStaticText" then
                  set elementText to (description of currentElement)
                  if elementText is not missing value and elementText is not "" then
                    set end of conversationText to elementText
                  end if
                end if
              end try
            end repeat
          end try
          
          -- Return the conversation text
          if (count of conversationText) > 0 then
            set AppleScript's text item delimiters to linefeed
            return conversationText as text
          else
            return "No response received from ChatGPT"
          end if
        end tell
      end tell
    `;
		const result = await runAppleScript(script);
		
		// Post-process the result to clean up any UI text that might have been captured
		let cleanedResult = result
			.replace(/Regenerate( response)?/g, '')
			.replace(/Continue generating/g, '')
			.replace(/▍/g, '')
			.trim();
			
		// More context-aware incomplete response detection
		const isLikelyComplete = 
			cleanedResult.length > 50 || // Longer responses are likely complete
			cleanedResult.endsWith('.') || 
			cleanedResult.endsWith('!') || 
			cleanedResult.endsWith('?') ||
			cleanedResult.endsWith(':') ||
			cleanedResult.endsWith(')') ||
			cleanedResult.endsWith('}') ||
			cleanedResult.endsWith(']') ||
			cleanedResult.includes('\n\n') || // Multiple paragraphs suggest completeness
			/^[A-Z].*[.!?]$/.test(cleanedResult); // Complete sentence structure
			
		if (cleanedResult.length > 0 && !isLikelyComplete) {
			console.warn("Warning: ChatGPT response may be incomplete");
		}
		
		return cleanedResult;
	} catch (error) {
		console.error("Error interacting with ChatGPT:", error);
		throw new Error(
			`Failed to get response from ChatGPT: ${
				error instanceof Error ? error.message : String(error)
			}`,
		);
	}
}

// Function to get the last message from ChatGPT conversation
async function getLastMessage(): Promise<string> {
	await checkChatGPTAccess();
	try {
		const script = `
      tell application "ChatGPT"
        activate
        delay 1
      end tell
      
      tell application "System Events"
        tell process "ChatGPT"
          -- Check if ChatGPT window exists
          if not (exists window 1) then
            return "ChatGPT window not found"
          end if
          
          -- Get all text elements
          set allTexts to {}
          try
            set allUIElements to entire contents of window 1
            repeat with i from 1 to count of allUIElements
              try
                set currentElement to item i of allUIElements
                if (role of currentElement) is "AXStaticText" then
                  set elementText to (description of currentElement)
                  if elementText is not missing value and elementText is not "" then
                    set end of allTexts to elementText
                  end if
                end if
              end try
            end repeat
          end try
          
          -- Find the last ChatGPT response
          set totalTexts to count of allTexts
          if totalTexts = 0 then
            return "No messages found"
          end if
          
          -- Look for user message pattern (working backwards)
          set chatGPTResponse to {}
          set foundUserMessage to false
          
          repeat with j from totalTexts to 1 by -1
            set currentText to item j of allTexts
            set textLength to length of currentText
            
            -- Check if this looks like a user message
            -- User messages are typically 10-100 chars, natural sentences
            if not foundUserMessage and textLength > 10 and textLength < 200 then
              -- Check if it's not a table cell or code snippet
              if currentText does not contain "✅" and currentText does not contain "❌" and currentText does not contain "<" and currentText does not contain ">" then
                -- This might be a user message, so everything after this is ChatGPT response
                set foundUserMessage to true
                -- Don't include the user message itself
              else
                -- Still part of ChatGPT response
                set beginning of chatGPTResponse to currentText
              end if
            else if foundUserMessage then
              -- We've found the boundary, stop here
              exit repeat
            else
              -- Still collecting ChatGPT response
              set beginning of chatGPTResponse to currentText
            end if
          end repeat
          
          -- If no user message found, take last 10 elements as ChatGPT response
          if not foundUserMessage then
            set chatGPTResponse to {}
            set startIndex to totalTexts - 9
            if startIndex < 1 then set startIndex to 1
            repeat with k from startIndex to totalTexts
              set end of chatGPTResponse to item k of allTexts
            end repeat
          end if
          
          -- Combine all parts of the ChatGPT response
          if (count of chatGPTResponse) > 0 then
            set AppleScript's text item delimiters to linefeed
            set fullResponse to chatGPTResponse as text
            set AppleScript's text item delimiters to ""
            return fullResponse
          else
            return "No ChatGPT response found"
          end if
        end tell
      end tell
    `;
		
		const result = await runAppleScript(script);
		
		// Clean up the result
		let cleanedResult = result
			.replace(/Regenerate( response)?/g, '')
			.replace(/Continue generating/g, '')
			.replace(/▍/g, '')
			.trim();
			
		return cleanedResult || "No last message found";
	} catch (error) {
		console.error("Error getting last message from ChatGPT:", error);
		throw new Error(
			`Failed to get last message from ChatGPT: ${
				error instanceof Error ? error.message : String(error)
			}`,
		);
	}
}

// Function to get available conversations
async function getConversations(): Promise<string[]> {
	try {
		// Run AppleScript to get conversations from ChatGPT app
		const result = await runAppleScript(`
      tell application "System Events"
        -- Check if ChatGPT process exists
        if not (exists process "ChatGPT") then
          return "ChatGPT is not running"
        end if
        
        tell process "ChatGPT"
          -- Check if ChatGPT window exists
          if not (exists window 1) then
            return "No ChatGPT window found"
          end if
          
          -- Activate ChatGPT and give it time to respond
          tell application "ChatGPT" to activate
          delay 1.5
          
          -- Try to get conversation titles
          set conversationsList to {}
          
          try
            -- Try to find conversation buttons in the sidebar
            -- Look for buttons in the scroll area (sidebar)
            if exists scroll area 1 of group 1 of splitter group 1 of group 1 of window 1 then
              set sidebarArea to scroll area 1 of group 1 of splitter group 1 of group 1 of window 1
              
              -- Get all UI elements in the sidebar
              set allElements to every UI element of sidebarArea
              repeat with elem in allElements
                try
                  -- Check if element is a button and has a name/title
                  if class of elem is button then
                    set buttonTitle to name of elem
                    if buttonTitle is not missing value and buttonTitle is not "" and buttonTitle is not "New chat" then
                      set end of conversationsList to buttonTitle
                    end if
                  end if
                end try
              end repeat
            end if
            
            -- If no conversations found, return appropriate message
            if (count of conversationsList) is 0 then
              return "No conversations found"
            end if
            
            return conversationsList
            
          on error errMsg
            -- Return error message for debugging
            return "Error accessing ChatGPT UI: " & errMsg
          end try
        end tell
      end tell
    `);

		// Parse the AppleScript result into an array
		if (result === "ChatGPT is not running") {
			console.error("ChatGPT application is not running");
			throw new Error("ChatGPT application is not running");
		} else if (result === "No ChatGPT window found") {
			console.error("No ChatGPT window found");
			throw new Error("No ChatGPT window found");
		} else if (result === "No conversations found") {
			console.error("No conversations found in ChatGPT");
			return []; // Return empty array instead of error message
		} else if (result.startsWith("Error:")) {
			console.error(result);
			throw new Error(result);
		}
		
		const conversations = result.split(", ");
		return conversations;
	} catch (error) {
		console.error("Error getting ChatGPT conversations:", error);
		throw new Error("Error retrieving conversations: " + (error instanceof Error ? error.message : String(error)));
	}
}

function isChatGPTArgs(args: unknown): args is {
	operation: "ask" | "get_conversations" | "get_last_message";
	prompt?: string;
	conversation_id?: string;
} {
	if (typeof args !== "object" || args === null) return false;

	const { operation, prompt, conversation_id } = args as any;

	if (!operation || !["ask", "get_conversations", "get_last_message"].includes(operation)) {
		return false;
	}(operation)) {
		return false;
	}

	// Validate required fields based on operation
	if (operation === "ask" && !prompt) return false;

	// Validate field types if present
	if (prompt && typeof prompt !== "string") return false;
	if (conversation_id && typeof conversation_id !== "string") return false;

	return true;
}

server.setRequestHandler(ListToolsRequestSchema, async () => ({
	tools: [CHATGPT_TOOL],
}));

server.setRequestHandler(CallToolRequestSchema, async (request) => {
	try {
		const { name, arguments: args } = request.params;

		if (!args) {
			throw new Error("No arguments provided");
		}

		if (name === "chatgpt") {
			if (!isChatGPTArgs(args)) {
				throw new Error("Invalid arguments for ChatGPT tool");
			}

			switch (args.operation) {
				case "ask": {
					if (!args.prompt) {
						throw new Error("Prompt is required for ask operation");
					}

					const response = await askChatGPT(args.prompt, args.conversation_id);

					return {
						content: [
							{
								type: "text",
								text: response || "No response received from ChatGPT.",
							},
						],
						isError: false,
					};
				}

				case "get_conversations": {
					const conversations = await getConversations();

					return {
						content: [
							{
								type: "text",
								text:
									conversations.length > 0
										? `Found ${conversations.length} conversation(s):\n\n${conversations.join("\n")}`
										: "No conversations found in ChatGPT.",
							},
						],
						isError: false,
					};
				}

				case "get_last_message": {
					const lastMessage = await getLastMessage();

					return {
						content: [
							{
								type: "text",
								text: lastMessage || "No last message found.",
							},
						],
						isError: false,
					};
				}

				case "get_last_message": {
					const lastMessage = await getLastMessage();

					return {
						content: [
							{
								type: "text",
								text: lastMessage || "No last message found.",
							},
						],
						isError: false,
					};
				}}`
										: "No conversations found in ChatGPT.",
							},
						],
						isError: false,
					};
				}

				default:
					throw new Error(`Unknown operation: ${args.operation}`);
			}
		}

		return {
			content: [{ type: "text", text: `Unknown tool: ${name}` }],
			isError: true,
		};
	} catch (error) {
		return {
			content: [
				{
					type: "text",
					text: `Error: ${error instanceof Error ? error.message : String(error)}`,
				},
			],
			isError: true,
		};
	}
});

const transport = new StdioServerTransport();

await server.connect(transport);
console.error("ChatGPT MCP Server running on stdio");
